<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC å®‰å…¨æ£€æµ‹</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 400px;
            width: 100%;
        }

        .icon {
            font-size: 3rem;
            margin-bottom: 20px;
        }

        h2 {
            color: #2d3748;
            margin-bottom: 20px;
            font-weight: 600;
        }

        #status {
            font-size: 1.1em;
            margin-top: 20px;
            color: #4a5568;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .info-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
        }

        .info-item {
            margin: 8px 0;
            font-size: 0.9em;
        }

        .info-label {
            font-weight: 600;
            color: #2d3748;
        }

        .info-value {
            color: #4a5568;
            margin-left: 10px;
        }

        .error {
            color: #e53e3e;
            background: #fed7d7;
            border: 1px solid #feb2b2;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            color: #38a169;
            background: #c6f6d5;
            border: 1px solid #9ae6b4;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">ğŸ”</div>
        <h2>WebRTC æ³„éœ²æ£€æµ‹</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        <div id="status">æ­£åœ¨åˆå§‹åŒ–æ£€æµ‹...</div>
        <div id="info-container"></div>
    </div>

    <script>
        const statusDiv = document.getElementById("status");
        const progressBar = document.getElementById("progress");
        const infoContainer = document.getElementById("info-container");

        let detectionData = {
            session: null,
            ip: null,
            webrtc_ips: [],
            fingerprint: {}
        };

        // æ›´æ–°è¿›åº¦æ¡
        function updateProgress(percent) {
            progressBar.style.width = percent + "%";
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(message) {
            statusDiv.textContent = message;
        }

        // æ˜¾ç¤ºä¿¡æ¯å¡ç‰‡
        function showInfoCard(title, items) {
            const card = document.createElement("div");
            card.className = "info-card";
            card.innerHTML = `<h4>${title}</h4>`;
            
            items.forEach(item => {
                const div = document.createElement("div");
                div.className = "info-item";
                div.innerHTML = `<span class="info-label">${item.label}:</span><span class="info-value">${item.value}</span>`;
                card.appendChild(div);
            });
            
            infoContainer.appendChild(card);
        }

        // è·å–å…¬ç½‘ IP
        async function getPublicIP() {
            try {
                updateStatus("æ­£åœ¨è·å–å…¬ç½‘ IP...");
                updateProgress(20);
                
                const response = await fetch("https://api.ipify.org?format=json");
                const data = await response.json();
                detectionData.ip = data.ip;
                
                showInfoCard("ç½‘ç»œä¿¡æ¯", [
                    { label: "å…¬ç½‘ IP", value: data.ip }
                ]);
                
                return data.ip;
            } catch (error) {
                throw new Error("è·å–å…¬ç½‘ IP å¤±è´¥");
            }
        }

        // è·å– WebRTC IP
        function getWebRTCIPs() {
            return new Promise((resolve, reject) => {
                updateStatus("æ­£åœ¨æ£€æµ‹ WebRTC IP...");
                updateProgress(40);
                
                const ips = new Set();
                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: "stun:stun.l.google.com:19302" },
                        { urls: "stun:stun1.l.google.com:19302" }
                    ]
                });

                let timeout = setTimeout(() => {
                    pc.close();
                    resolve([...ips]);
                }, 10000);

                pc.createDataChannel("");
                pc.createOffer().then(offer => pc.setLocalDescription(offer));
                
                pc.onicecandidate = (event) => {
                    if (event && event.candidate && event.candidate.candidate) {
                        const candidate = event.candidate.candidate;
                        const match = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/);
                        if (match) {
                            ips.add(match[1]);
                        }
                    } else if (!event.candidate) {
                        clearTimeout(timeout);
                        pc.close();
                        resolve([...ips]);
                    }
                };

                pc.onicegatheringstatechange = () => {
                    if (pc.iceGatheringState === 'complete') {
                        clearTimeout(timeout);
                        pc.close();
                        resolve([...ips]);
                    }
                };
            });
        }

        // è·å–æµè§ˆå™¨æŒ‡çº¹
        function getBrowserFingerprint() {
            updateStatus("æ­£åœ¨æ”¶é›†æµè§ˆå™¨æŒ‡çº¹...");
            updateProgress(60);

            const ua = navigator.userAgent;
            const screen = window.screen;
            const fingerprint = {
                userAgent: ua,
                browser: getBrowserInfo(ua),
                os: getOSInfo(ua),
                screen: {
                    width: screen.width,
                    height: screen.height,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth
                },
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                languages: navigator.languages,
                platform: navigator.platform,
                hardwareConcurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory,
                connection: navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt
                } : null,
                cookieEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                maxTouchPoints: navigator.maxTouchPoints
            };

            detectionData.fingerprint = fingerprint;

            showInfoCard("è®¾å¤‡ä¿¡æ¯", [
                { label: "æµè§ˆå™¨", value: `${fingerprint.browser.name} ${fingerprint.browser.version}` },
                { label: "æ“ä½œç³»ç»Ÿ", value: `${fingerprint.os.name} ${fingerprint.os.version}` },
                { label: "å±å¹•åˆ†è¾¨ç‡", value: `${fingerprint.screen.width}x${fingerprint.screen.height}` },
                { label: "æ—¶åŒº", value: fingerprint.timezone },
                { label: "è¯­è¨€", value: fingerprint.language }
            ]);

            return fingerprint;
        }

        // è§£ææµè§ˆå™¨ä¿¡æ¯
        function getBrowserInfo(ua) {
            const browsers = [
                { name: "Chrome", regex: /Chrome\/(\d+)/ },
                { name: "Firefox", regex: /Firefox\/(\d+)/ },
                { name: "Safari", regex: /Safari\/(\d+)/ },
                { name: "Edge", regex: /Edge\/(\d+)/ },
                { name: "Opera", regex: /Opera\/(\d+)/ }
            ];

            for (const browser of browsers) {
                const match = ua.match(browser.regex);
                if (match) {
                    return { name: browser.name, version: match[1] };
                }
            }
            return { name: "Unknown", version: "" };
        }

        // è§£ææ“ä½œç³»ç»Ÿä¿¡æ¯
        function getOSInfo(ua) {
            const systems = [
                { name: "Windows", regex: /Windows NT (\d+\.\d+)/ },
                { name: "macOS", regex: /Mac OS X (\d+[._]\d+)/ },
                { name: "Linux", regex: /Linux/ },
                { name: "Android", regex: /Android (\d+\.\d+)/ },
                { name: "iOS", regex: /OS (\d+_\d+)/ }
            ];

            for (const system of systems) {
                const match = ua.match(system.regex);
                if (match) {
                    return { name: system.name, version: match[1] || "" };
                }
            }
            return { name: "Unknown", version: "" };
        }

        // å‘é€æ•°æ®åˆ° Telegram
        async function sendToTelegram() {
            try {
                updateStatus("æ­£åœ¨å‘é€æ£€æµ‹ç»“æœ...");
                updateProgress(80);

                const urlParams = new URLSearchParams(window.location.search);
                detectionData.session = urlParams.get("session");

                console.log("æ£€æµ‹æ•°æ®:", detectionData);

                if (window.Telegram && window.Telegram.WebApp) {
                    Telegram.WebApp.ready();
                    Telegram.WebApp.sendData(JSON.stringify(detectionData));
                    
                    updateStatus("âœ… æ£€æµ‹å®Œæˆï¼Œæ­£åœ¨è¿”å›ç»“æœ...");
                    updateProgress(100);
                } else {
                    throw new Error("Telegram WebApp ä¸å¯ç”¨");
                }
            } catch (error) {
                console.error("å‘é€æ•°æ®é”™è¯¯:", error);
                updateStatus("âŒ å‘é€å¤±è´¥: " + error.message);
                infoContainer.innerHTML += `<div class="error">å‘é€å¤±è´¥: ${error.message}</div>`;
            }
        }

        // ä¸»æ£€æµ‹æµç¨‹
        async function runDetection() {
            try {
                updateProgress(10);
                
                // è·å–å…¬ç½‘ IP
                await getPublicIP();
                
                // è·å– WebRTC IP
                const webrtcIPs = await getWebRTCIPs();
                detectionData.webrtc_ips = webrtcIPs;
                
                showInfoCard("WebRTC æ£€æµ‹", [
                    { label: "æ£€æµ‹åˆ°çš„ IP", value: webrtcIPs.length > 0 ? webrtcIPs.join(", ") : "æ— " },
                    { label: "IP æ•°é‡", value: webrtcIPs.length }
                ]);
                
                // è·å–æµè§ˆå™¨æŒ‡çº¹
                getBrowserFingerprint();
                
                // å‘é€åˆ° Telegram
                await sendToTelegram();
                
            } catch (error) {
                console.error("æ£€æµ‹è¿‡ç¨‹å‡ºé”™:", error);
                updateStatus("âŒ æ£€æµ‹å‡ºé”™: " + error.message);
                infoContainer.innerHTML += `<div class="error">æ£€æµ‹å‡ºé”™: ${error.message}</div>`;
            }
        }

        // å¯åŠ¨æ£€æµ‹
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(runDetection, 1000);
        });
    </script>
</body>
</html>
