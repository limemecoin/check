<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPé£é™© å®‰å…¨æ£€æµ‹</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 400px;
            width: 100%;
        }

        .icon {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        h2 {
            color: #2d3748;
            margin-bottom: 20px;
            font-weight: 600;
        }

        #status {
            font-size: 1.1em;
            margin-top: 20px;
            color: #4a5568;
            min-height: 1.5em;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .info-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            text-align: left;
        }

        .info-item {
            margin: 10px 0;
            font-size: 0.95em;
        }

        .info-label {
            font-weight: 600;
            color: #2d3748;
            display: inline-block;
            width: 120px;
        }

        .info-value {
            color: #4a5568;
            word-break: break-all;
        }

        .error {
            color: #e53e3e;
            background: #fed7d7;
            border: 1px solid #feb2b2;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success {
            color: #38a169;
            background: #c6f6d5;
            border: 1px solid #9ae6b4;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .warning {
            color: #d69e2e;
            background: #faf5cc;
            border: 1px solid #f6e05e;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4facfe;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tech-details {
            font-size: 0.8em;
            color: #666;
            margin-top: 10px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">ğŸ”</div>
        <h2>IPé£é™© æ³„éœ²æ£€æµ‹</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        <div id="status"><div class="spinner"></div>æ­£åœ¨åˆå§‹åŒ–æ£€æµ‹...</div>
        <div id="info-container"></div>
    </div>

    <script>
        const statusDiv = document.getElementById("status");
        const progressBar = document.getElementById("progress");
        const infoContainer = document.getElementById("info-container");

        let detectionData = {
            session: null,
            ip: null,
            webrtc_ips: [],
            fingerprint: {},
            leak_detected: false,
            risk_level: "LOW"
        };

        // æ›´æ–°è¿›åº¦æ¡
        function updateProgress(percent) {
            progressBar.style.width = percent + "%";
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(message, showSpinner = true) {
            statusDiv.innerHTML = showSpinner ? `<div class="spinner"></div>${message}` : message;
        }

        // æ˜¾ç¤ºä¿¡æ¯å¡ç‰‡
        function showInfoCard(title, items) {
            const card = document.createElement("div");
            card.className = "info-card";
            card.innerHTML = `<h4 style="margin-bottom: 15px; color: #2d3748;">${title}</h4>`;
            
            items.forEach(item => {
                const div = document.createElement("div");
                div.className = "info-item";
                div.innerHTML = `<span class="info-label">${item.label}:</span><span class="info-value">${item.value}</span>`;
                card.appendChild(div);
            });
            
            infoContainer.appendChild(card);
        }

        // æ˜¾ç¤ºè­¦å‘Šæˆ–æˆåŠŸæ¶ˆæ¯
        function showMessage(message, type = "info") {
            const messageDiv = document.createElement("div");
            messageDiv.className = type;
            messageDiv.textContent = message;
            infoContainer.appendChild(messageDiv);
        }

        // æ£€æŸ¥æ˜¯å¦ä¸ºå†…ç½‘IP
        function isPrivateIP(ip) {
            const privateRanges = [
                /^10\./,
                /^172\.(1[6-9]|2\d|3[0-1])\./,
                /^192\.168\./,
                /^127\./,
                /^169\.254\./,
                /^::1$/,
                /^fe80:/,
                /^fc00:/,
                /^fd00:/,
                /^::ffff:0:0\/96/
            ];
            return privateRanges.some(range => range.test(ip));
        }

        // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„å…¬ç½‘IP
        function isValidPublicIP(ip) {
            if (!ip || ip === "0.0.0.0" || ip === "127.0.0.1") return false;
            if (isPrivateIP(ip)) return false;
            
            // æ£€æŸ¥IPæ ¼å¼
            const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            const ipv6Regex = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
            
            return ipv4Regex.test(ip) || ipv6Regex.test(ip);
        }

        // è·å–å…¬ç½‘ IP
        async function getPublicIP() {
            try {
                updateStatus("æ­£åœ¨è·å–å…¬ç½‘ IP...");
                updateProgress(20);
                
                const response = await fetch("https://api.ipify.org?format=json");
                const data = await response.json();
                detectionData.ip = data.ip;
                
                showInfoCard("ç½‘ç»œä¿¡æ¯", [
                    { label: "å…¬ç½‘ IP", value: data.ip || "æœªè·å–åˆ°" }
                ]);
                
                return data.ip;
            } catch (error) {
                console.error("è·å–å…¬ç½‘ IP å¤±è´¥:", error);
                showMessage("âš ï¸ è·å–å…¬ç½‘ IP å¤±è´¥ï¼Œå°†ç»§ç»­è¿›è¡Œ WebRTC æ£€æµ‹", "warning");
                return null;
            }
        }

        // è·å– WebRTC IP - æ”¹è¿›ç‰ˆæœ¬
        function getWebRTCIPs() {
            return new Promise((resolve) => {
                updateStatus("æ­£åœ¨æ£€æµ‹ WebRTC IP æ³„éœ²...");
                updateProgress(50);
                
                const ips = new Set();
                const configs = [
                    { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] },
                    { iceServers: [{ urls: "stun:stun1.l.google.com:19302" }] },
                    { iceServers: [{ urls: "stun:stun.services.mozilla.com" }] },
                    { iceServers: [{ urls: "stun:stun.cloudflare.com:3478" }] }
                ];

                let completedConnections = 0;
                const totalConnections = configs.length;

                configs.forEach((config, index) => {
                    setTimeout(() => {
                        const pc = new RTCPeerConnection(config);
                        
                        const timeout = setTimeout(() => {
                            pc.close();
                            completedConnections++;
                            if (completedConnections === totalConnections) {
                                resolve([...ips]);
                            }
                        }, 8000);

                        pc.createDataChannel("");
                        pc.createOffer().then(offer => pc.setLocalDescription(offer));
                        
                        pc.onicecandidate = (event) => {
                            if (event && event.candidate && event.candidate.candidate) {
                                const candidate = event.candidate.candidate;
                                
                                // æ›´å…¨é¢çš„IPæå–
                                const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/g;
                                const matches = candidate.match(ipRegex);
                                
                                if (matches) {
                                    matches.forEach(ip => {
                                        if (ip && !ip.startsWith('0.') && !ip.startsWith('127.')) {
                                            ips.add(ip);
                                        }
                                    });
                                }
                            } else if (!event.candidate) {
                                clearTimeout(timeout);
                                pc.close();
                                completedConnections++;
                                if (completedConnections === totalConnections) {
                                    resolve([...ips]);
                                }
                            }
                        };

                        pc.onicegatheringstatechange = () => {
                            if (pc.iceGatheringState === 'complete') {
                                clearTimeout(timeout);
                                pc.close();
                                completedConnections++;
                                if (completedConnections === totalConnections) {
                                    resolve([...ips]);
                                }
                            }
                        };
                    }, index * 1000); // å»¶è¿Ÿå¯åŠ¨ä¸åŒçš„è¿æ¥
                });

                // æ€»ä½“è¶…æ—¶
                setTimeout(() => {
                    resolve([...ips]);
                }, 15000);
            });
        }

        // åˆ†æIPæ³„éœ²é£é™©
        function analyzeIPLeak(publicIP, webrtcIPs) {
            const leakedIPs = [];
            
            if (!webrtcIPs || webrtcIPs.length === 0) {
                return { leaked: false, risk: "LOW", leakedIPs: [] };
            }

            // è¿‡æ»¤æ‰æ— æ•ˆçš„IP
            const validWebRTCIPs = webrtcIPs.filter(ip => {
                if (!ip || ip === publicIP) return false;
                if (ip.startsWith('0.') || ip === '127.0.0.1') return false;
                return true;
            });

            // æŸ¥æ‰¾çœŸæ­£çš„æ³„éœ²IPï¼ˆä¸å…¬ç½‘IPä¸åŒçš„æœ‰æ•ˆå…¬ç½‘IPï¼‰
            validWebRTCIPs.forEach(ip => {
                if (isValidPublicIP(ip) && ip !== publicIP) {
                    leakedIPs.push(ip);
                }
            });

            const leaked = leakedIPs.length > 0;
            let risk = "LOW";
            
            if (leaked) {
                risk = leakedIPs.length > 1 ? "HIGH" : "MEDIUM";
            }

            return { leaked, risk, leakedIPs };
        }

        // è·å–åŸºæœ¬çš„æµè§ˆå™¨æŒ‡çº¹
        function getBasicFingerprint() {
            updateStatus("æ­£åœ¨æ”¶é›†è®¾å¤‡ä¿¡æ¯...");
            updateProgress(70);

            const ua = navigator.userAgent;
            const screen = window.screen;
            const fingerprint = {
                userAgent: ua,
                browser: getBrowserInfo(ua),
                os: getOSInfo(ua),
                screen: {
                    width: screen.width,
                    height: screen.height,
                    colorDepth: screen.colorDepth
                },
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                platform: navigator.platform
            };

            detectionData.fingerprint = fingerprint;

            showInfoCard("è®¾å¤‡ä¿¡æ¯", [
                { label: "æµè§ˆå™¨", value: `${fingerprint.browser.name} ${fingerprint.browser.version}` },
                { label: "æ“ä½œç³»ç»Ÿ", value: `${fingerprint.os.name} ${fingerprint.os.version}` },
                { label: "å±å¹•åˆ†è¾¨ç‡", value: `${fingerprint.screen.width}x${fingerprint.screen.height}` },
                { label: "æ—¶åŒº", value: fingerprint.timezone },
                { label: "è¯­è¨€", value: fingerprint.language }
            ]);

            return fingerprint;
        }

        // è§£ææµè§ˆå™¨ä¿¡æ¯
        function getBrowserInfo(ua) {
            const browsers = [
                { name: "Chrome", regex: /Chrome\/(\d+)/ },
                { name: "Firefox", regex: /Firefox\/(\d+)/ },
                { name: "Safari", regex: /Safari\/(\d+)/ },
                { name: "Edge", regex: /Edge\/(\d+)/ },
                { name: "Opera", regex: /Opera\/(\d+)/ }
            ];

            for (const browser of browsers) {
                const match = ua.match(browser.regex);
                if (match) {
                    return { name: browser.name, version: match[1] };
                }
            }
            return { name: "Unknown", version: "" };
        }

        // è§£ææ“ä½œç³»ç»Ÿä¿¡æ¯
        function getOSInfo(ua) {
            const systems = [
                { name: "Windows", regex: /Windows NT (\d+\.\d+)/ },
                { name: "macOS", regex: /Mac OS X (\d+[._]\d+)/ },
                { name: "Linux", regex: /Linux/ },
                { name: "Android", regex: /Android (\d+\.\d+)/ },
                { name: "iOS", regex: /OS (\d+_\d+)/ }
            ];

            for (const system of systems) {
                const match = ua.match(system.regex);
                if (match) {
                    return { name: system.name, version: match[1] || "" };
                }
            }
            return { name: "Unknown", version: "" };
        }

        // å‘é€æ•°æ®åˆ° Telegram
        async function sendToTelegram() {
            try {
                updateStatus("æ­£åœ¨å‘é€æ£€æµ‹ç»“æœ...", false);
                updateProgress(90);

                const urlParams = new URLSearchParams(window.location.search);
                detectionData.session = urlParams.get("session") || `session_${Date.now()}`;

                console.log("æ£€æµ‹æ•°æ®:", detectionData);

                if (window.Telegram && window.Telegram.WebApp) {
                    Telegram.WebApp.ready();
                    Telegram.WebApp.sendData(JSON.stringify(detectionData));
                    
                    updateStatus("âœ… æ£€æµ‹å®Œæˆï¼Œæ­£åœ¨è¿”å›ç»“æœ...", false);
                    updateProgress(100);
                    
                    // å»¶è¿Ÿå…³é—­
                    setTimeout(() => {
                        Telegram.WebApp.close();
                    }, 2000);
                } else {
                    throw new Error("Telegram WebApp ä¸å¯ç”¨");
                }
            } catch (error) {
                console.error("å‘é€æ•°æ®é”™è¯¯:", error);
                updateStatus("âŒ å‘é€å¤±è´¥: " + error.message, false);
                showMessage("å‘é€å¤±è´¥: " + error.message, "error");
            }
        }

        // ä¸»æ£€æµ‹æµç¨‹
        async function runDetection() {
            try {
                updateProgress(10);
                
                // è·å–å…¬ç½‘ IP
                const publicIP = await getPublicIP();
                
                // è·å– WebRTC IP
                const webrtcIPs = await getWebRTCIPs();
                detectionData.webrtc_ips = webrtcIPs;
                
                // åˆ†æIPæ³„éœ²
                const leakAnalysis = analyzeIPLeak(publicIP, webrtcIPs);
                detectionData.leak_detected = leakAnalysis.leaked;
                detectionData.risk_level = leakAnalysis.risk;
                
                // æ˜¾ç¤ºWebRTCæ£€æµ‹ç»“æœ
                const webrtcInfo = [];
                if (webrtcIPs.length > 0) {
                    webrtcInfo.push({ label: "æ£€æµ‹åˆ°çš„ IP", value: webrtcIPs.join(", ") });
                    webrtcInfo.push({ label: "IP æ•°é‡", value: webrtcIPs.length.toString() });
                    
                    if (leakAnalysis.leaked) {
                        webrtcInfo.push({ label: "æ³„éœ²çŠ¶æ€", value: "âš ï¸ æ£€æµ‹åˆ°æ³„éœ²" });
                        webrtcInfo.push({ label: "é£é™©ç­‰çº§", value: leakAnalysis.risk });
                    } else {
                        webrtcInfo.push({ label: "æ³„éœ²çŠ¶æ€", value: "âœ… æœªæ£€æµ‹åˆ°æ³„éœ²" });
                    }
                } else {
                    webrtcInfo.push({ label: "æ£€æµ‹ç»“æœ", value: "æœªæ£€æµ‹åˆ° WebRTC IP" });
                }
                
                showInfoCard("WebRTC æ£€æµ‹", webrtcInfo);
                
                // æ˜¾ç¤ºç»“æœæ¶ˆæ¯
                if (leakAnalysis.leaked) {
                    showMessage(`ğŸš¨ æ£€æµ‹åˆ° IP æ³„éœ²ï¼æ³„éœ²äº† ${leakAnalysis.leakedIPs.length} ä¸ªIPåœ°å€`, "error");
                } else {
                    showMessage("âœ… æœªæ£€æµ‹åˆ° IP æ³„éœ²", "success");
                }
                
                // è·å–åŸºæœ¬æŒ‡çº¹ä¿¡æ¯
                getBasicFingerprint();
                
                // å‘é€åˆ° Telegram
                await sendToTelegram();
                
            } catch (error) {
                console.error("æ£€æµ‹è¿‡ç¨‹å‡ºé”™:", error);
                updateStatus("âŒ æ£€æµ‹å‡ºé”™: " + error.message, false);
                showMessage("æ£€æµ‹å‡ºé”™: " + error.message, "error");
            }
        }

        // å¯åŠ¨æ£€æµ‹
        document.addEventListener('DOMContentLoaded', function() {
            // æ£€æŸ¥WebRTCæ”¯æŒ
            if (!window.RTCPeerConnection) {
                showMessage("âŒ æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ WebRTC", "error");
                return;
            }
            
            setTimeout(runDetection, 1000);
        });
    </script>
</body>
</html>
