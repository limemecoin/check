<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPÈ£éÈô© ÂÆâÂÖ®Ê£ÄÊµã</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 400px;
            width: 100%;
        }

        .icon {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        h2 {
            color: #2d3748;
            margin-bottom: 20px;
            font-weight: 600;
        }

        #status {
            font-size: 1.1em;
            margin-top: 20px;
            color: #4a5568;
            min-height: 1.5em;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .info-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            text-align: left;
        }

        .info-item {
            margin: 10px 0;
            font-size: 0.95em;
        }

        .info-label {
            font-weight: 600;
            color: #2d3748;
            display: inline-block;
            width: 120px;
        }

        .info-value {
            color: #4a5568;
            word-break: break-all;
        }

        .error {
            color: #e53e3e;
            background: #fed7d7;
            border: 1px solid #feb2b2;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success {
            color: #38a169;
            background: #c6f6d5;
            border: 1px solid #9ae6b4;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .warning {
            color: #d69e2e;
            background: #faf5cc;
            border: 1px solid #f6e05e;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4facfe;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tech-details {
            font-size: 0.8em;
            color: #666;
            margin-top: 10px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">üîê</div>
        <h2>IPÈ£éÈô© Ê≥ÑÈú≤Ê£ÄÊµã</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        <div id="status"><div class="spinner"></div>Ê≠£Âú®ÂàùÂßãÂåñÊ£ÄÊµã...</div>
        <div id="info-container"></div>
    </div>

    <script>
        const statusDiv = document.getElementById("status");
        const progressBar = document.getElementById("progress");
        const infoContainer = document.getElementById("info-container");

        let detectionData = {
            session: null,
            ip: null,
            webrtc_ips: [],
            fingerprint: {},
            leak_detected: false,
            risk_level: "LOW"
        };

        // Êõ¥Êñ∞ËøõÂ∫¶Êù°
        function updateProgress(percent) {
            progressBar.style.width = percent + "%";
        }

        // Êõ¥Êñ∞Áä∂ÊÄÅ
        function updateStatus(message, showSpinner = true) {
            statusDiv.innerHTML = showSpinner ? `<div class="spinner"></div>${message}` : message;
        }

        // ÊòæÁ§∫‰ø°ÊÅØÂç°Áâá
        function showInfoCard(title, items) {
            const card = document.createElement("div");
            card.className = "info-card";
            card.innerHTML = `<h4 style="margin-bottom: 15px; color: #2d3748;">${title}</h4>`;
            
            items.forEach(item => {
                const div = document.createElement("div");
                div.className = "info-item";
                div.innerHTML = `<span class="info-label">${item.label}:</span><span class="info-value">${item.value}</span>`;
                card.appendChild(div);
            });
            
            infoContainer.appendChild(card);
        }

        // ÊòæÁ§∫Ë≠¶ÂëäÊàñÊàêÂäüÊ∂àÊÅØ
        function showMessage(message, type = "info") {
            const messageDiv = document.createElement("div");
            messageDiv.className = type;
            messageDiv.textContent = message;
            infoContainer.appendChild(messageDiv);
        }

        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÂÜÖÁΩëIP
        function isPrivateIP(ip) {
            const privateRanges = [
                /^10\./,
                /^172\.(1[6-9]|2\d|3[0-1])\./,
                /^192\.168\./,
                /^127\./,
                /^169\.254\./,
                /^::1$/,
                /^fe80:/,
                /^fc00:/,
                /^fd00:/,
                /^::ffff:0:0\/96/
            ];
            return privateRanges.some(range => range.test(ip));
        }

        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊúâÊïàÁöÑÂÖ¨ÁΩëIP
        function isValidPublicIP(ip) {
            if (!ip || ip === "0.0.0.0" || ip === "127.0.0.1") return false;
            if (isPrivateIP(ip)) return false;
            
            // Ê£ÄÊü•IPÊ†ºÂºè
            const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            const ipv6Regex = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
            
            return ipv4Regex.test(ip) || ipv6Regex.test(ip);
        }

        // Ëé∑ÂèñÂÖ¨ÁΩë IP
        async function getPublicIP() {
            try {
                updateStatus("Ê≠£Âú®Ëé∑ÂèñÂÖ¨ÁΩë IP...");
                updateProgress(20);
                
                const response = await fetch("https://api.ipify.org?format=json");
                const data = await response.json();
                detectionData.ip = data.ip;
                
                showInfoCard("ÁΩëÁªú‰ø°ÊÅØ", [
                    { label: "ÂÖ¨ÁΩë IP", value: data.ip || "Êú™Ëé∑ÂèñÂà∞" }
                ]);
                
                return data.ip;
            } catch (error) {
                console.error("Ëé∑ÂèñÂÖ¨ÁΩë IP Â§±Ë¥•:", error);
                showMessage("‚ö†Ô∏è Ëé∑ÂèñÂÖ¨ÁΩë IP Â§±Ë¥•ÔºåÂ∞ÜÁªßÁª≠ËøõË°å WebRTC Ê£ÄÊµã", "warning");
                return null;
            }
        }

        // Ëé∑Âèñ WebRTC IP - ÊîπËøõÁâàÊú¨
        function getWebRTCIPs() {
            return new Promise((resolve) => {
                updateStatus("Ê≠£Âú®Ê£ÄÊµã WebRTC IP Ê≥ÑÈú≤...");
                updateProgress(50);
                
                const ips = new Set();
                const configs = [
                    { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] },
                    { iceServers: [{ urls: "stun:stun1.l.google.com:19302" }] },
                    { iceServers: [{ urls: "stun:stun.services.mozilla.com" }] },
                    { iceServers: [{ urls: "stun:stun.cloudflare.com:3478" }] }
                ];

                let completedConnections = 0;
                const totalConnections = configs.length;

                configs.forEach((config, index) => {
                    setTimeout(() => {
                        const pc = new RTCPeerConnection(config);
                        
                        const timeout = setTimeout(() => {
                            pc.close();
                            completedConnections++;
                            if (completedConnections === totalConnections) {
                                resolve([...ips]);
                            }
                        }, 8000);

                        pc.createDataChannel("");
                        pc.createOffer().then(offer => pc.setLocalDescription(offer));
                        
                        pc.onicecandidate = (event) => {
                            if (event && event.candidate && event.candidate.candidate) {
                                const candidate = event.candidate.candidate;
                                
                                // Êõ¥ÂÖ®Èù¢ÁöÑIPÊèêÂèñ
                                const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/g;
                                const matches = candidate.match(ipRegex);
                                
                                if (matches) {
                                    matches.forEach(ip => {
                                        if (ip && !ip.startsWith('0.') && !ip.startsWith('127.')) {
                                            ips.add(ip);
                                        }
                                    });
                                }
                            } else if (!event.candidate) {
                                clearTimeout(timeout);
                                pc.close();
                                completedConnections++;
                                if (completedConnections === totalConnections) {
                                    resolve([...ips]);
                                }
                            }
                        };

                        pc.onicegatheringstatechange = () => {
                            if (pc.iceGatheringState === 'complete') {
                                clearTimeout(timeout);
                                pc.close();
                                completedConnections++;
                                if (completedConnections === totalConnections) {
                                    resolve([...ips]);
                                }
                            }
                        };
                    }, index * 1000); // Âª∂ËøüÂêØÂä®‰∏çÂêåÁöÑËøûÊé•
                });

                // ÊÄª‰ΩìË∂ÖÊó∂
                setTimeout(() => {
                    resolve([...ips]);
                }, 15000);
            });
        }

        // ÂàÜÊûêIPÊ≥ÑÈú≤È£éÈô©
        function analyzeIPLeak(publicIP, webrtcIPs) {
            const leakedIPs = [];
            
            if (!webrtcIPs || webrtcIPs.length === 0) {
                return { leaked: false, risk: "LOW", leakedIPs: [] };
            }

            // ËøáÊª§ÊéâÊó†ÊïàÁöÑIP
            const validWebRTCIPs = webrtcIPs.filter(ip => {
                if (!ip || ip === publicIP) return false;
                if (ip.startsWith('0.') || ip === '127.0.0.1') return false;
                return true;
            });

            // Êü•ÊâæÁúüÊ≠£ÁöÑÊ≥ÑÈú≤IPÔºà‰∏éÂÖ¨ÁΩëIP‰∏çÂêåÁöÑÊúâÊïàÂÖ¨ÁΩëIPÔºâ
            validWebRTCIPs.forEach(ip => {
                if (isValidPublicIP(ip) && ip !== publicIP) {
                    leakedIPs.push(ip);
                }
            });

            const leaked = leakedIPs.length > 0;
            let risk = "LOW";
            
            if (leaked) {
                risk = leakedIPs.length > 1 ? "HIGH" : "MEDIUM";
            }

            return { leaked, risk, leakedIPs };
        }

        // Ëé∑ÂèñÂü∫Êú¨ÁöÑÊµèËßàÂô®ÊåáÁ∫π
        function getBasicFingerprint() {
            updateStatus("Ê≠£Âú®Êî∂ÈõÜËÆæÂ§á‰ø°ÊÅØ...");
            updateProgress(70);

            const ua = navigator.userAgent;
            const screen = window.screen;
            const fingerprint = {
                userAgent: ua,
                browser: getBrowserInfo(ua),
                os: getOSInfo(ua),
                screen: {
                    width: screen.width,
                    height: screen.height,
                    colorDepth: screen.colorDepth
                },
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                platform: navigator.platform
            };

            detectionData.fingerprint = fingerprint;

            showInfoCard("ËÆæÂ§á‰ø°ÊÅØ", [
                { label: "ÊµèËßàÂô®", value: `${fingerprint.browser.name} ${fingerprint.browser.version}` },
                { label: "Êìç‰ΩúÁ≥ªÁªü", value: `${fingerprint.os.name} ${fingerprint.os.version}` },
                { label: "Â±èÂπïÂàÜËæ®Áéá", value: `${fingerprint.screen.width}x${fingerprint.screen.height}` },
                { label: "Êó∂Âå∫", value: fingerprint.timezone },
                { label: "ËØ≠Ë®Ä", value: fingerprint.language }
            ]);

            return fingerprint;
        }

        // Ëß£ÊûêÊµèËßàÂô®‰ø°ÊÅØ
        function getBrowserInfo(ua) {
            const browsers = [
                { name: "Chrome", regex: /Chrome\/(\d+)/ },
                { name: "Firefox", regex: /Firefox\/(\d+)/ },
                { name: "Safari", regex: /Safari\/(\d+)/ },
                { name: "Edge", regex: /Edge\/(\d+)/ },
                { name: "Opera", regex: /Opera\/(\d+)/ }
            ];

            for (const browser of browsers) {
                const match = ua.match(browser.regex);
                if (match) {
                    return { name: browser.name, version: match[1] };
                }
            }
            return { name: "Unknown", version: "" };
        }

        // Ëß£ÊûêÊìç‰ΩúÁ≥ªÁªü‰ø°ÊÅØ
        function getOSInfo(ua) {
            const systems = [
                { name: "Windows", regex: /Windows NT (\d+\.\d+)/ },
                { name: "macOS", regex: /Mac OS X (\d+[._]\d+)/ },
                { name: "Linux", regex: /Linux/ },
                { name: "Android", regex: /Android (\d+\.\d+)/ },
                { name: "iOS", regex: /OS (\d+_\d+)/ }
            ];

            for (const system of systems) {
                const match = ua.match(system.regex);
                if (match) {
                    return { name: system.name, version: match[1] || "" };
                }
            }
            return { name: "Unknown", version: "" };
        }

        // ÂèëÈÄÅÊï∞ÊçÆÂà∞ Telegram
        async function sendToTelegram() {
            try {
                updateStatus("Ê≠£Âú®ÂèëÈÄÅÊ£ÄÊµãÁªìÊûú...", false);
                updateProgress(90);

                const urlParams = new URLSearchParams(window.location.search);
                detectionData.session = urlParams.get("session") || `session_${Date.now()}`;

                console.log("Ê£ÄÊµãÊï∞ÊçÆ:", detectionData);

                if (window.Telegram && window.Telegram.WebApp) {
                    Telegram.WebApp.ready();
                    Telegram.WebApp.sendData(JSON.stringify(detectionData));
                    
                    updateStatus("‚úÖ Ê£ÄÊµãÂÆåÊàêÔºåÊ≠£Âú®ËøîÂõûÁªìÊûú...", false);
                    updateProgress(100);
                    
                    // Âª∂ËøüÂÖ≥Èó≠
                    setTimeout(() => {
                        Telegram.WebApp.close();
                    }, 2000);
                } else {
                    throw new Error("Telegram WebApp ‰∏çÂèØÁî®");
                }
            } catch (error) {
                console.error("ÂèëÈÄÅÊï∞ÊçÆÈîôËØØ:", error);
                updateStatus("‚ùå ÂèëÈÄÅÂ§±Ë¥•: " + error.message, false);
                showMessage("ÂèëÈÄÅÂ§±Ë¥•: " + error.message, "error");
            }
        }

        // ‰∏ªÊ£ÄÊµãÊµÅÁ®ã
        async function runDetection() {
            try {
                updateProgress(10);
                
                // Ëé∑ÂèñÂÖ¨ÁΩë IP
                const publicIP = await getPublicIP();
                
                // Ëé∑Âèñ WebRTC IP
                const webrtcIPs = await getWebRTCIPs();
                detectionData.webrtc_ips = webrtcIPs;
                
                // ÂàÜÊûêIPÊ≥ÑÈú≤
                const leakAnalysis = analyzeIPLeak(publicIP, webrtcIPs);
                detectionData.leak_detected = leakAnalysis.leaked;
                detectionData.risk_level = leakAnalysis.risk;
                
                // ÊòæÁ§∫WebRTCÊ£ÄÊµãÁªìÊûú
                const webrtcInfo = [];
                if (webrtcIPs.length > 0) {
                    webrtcInfo.push({ label: "Ê£ÄÊµãÂà∞ÁöÑ IP", value: webrtcIPs.join(", ") });
                    webrtcInfo.push({ label: "IP Êï∞Èáè", value: webrtcIPs.length.toString() });
                    
                    if (leakAnalysis.leaked) {
                        webrtcInfo.push({ label: "Ê≥ÑÈú≤Áä∂ÊÄÅ", value: "‚ö†Ô∏è Ê£ÄÊµãÂà∞Ê≥ÑÈú≤" });
                        webrtcInfo.push({ label: "È£éÈô©Á≠âÁ∫ß", value: leakAnalysis.risk });
                    } else {
                        webrtcInfo.push({ label: "Ê≥ÑÈú≤Áä∂ÊÄÅ", value: "‚úÖ Êú™Ê£ÄÊµãÂà∞Ê≥ÑÈú≤" });
                    }
                } else {
                    webrtcInfo.push({ label: "Ê£ÄÊµãÁªìÊûú", value: "Êú™Ê£ÄÊµãÂà∞ WebRTC IP" });
                }
                
                showInfoCard("WebRTC Ê£ÄÊµã", webrtcInfo);
                
                // ÊòæÁ§∫ÁªìÊûúÊ∂àÊÅØ
                if (leakAnalysis.leaked) {
                    showMessage(`üö® Ê£ÄÊµãÂà∞ IP Ê≥ÑÈú≤ÔºÅÊ≥ÑÈú≤‰∫Ü ${leakAnalysis.leakedIPs.length} ‰∏™IPÂú∞ÂùÄ`, "error");
                } else {
                    showMessage("‚úÖ Êú™Ê£ÄÊµãÂà∞ IP Ê≥ÑÈú≤", "success");
                }
                
                // Ëé∑ÂèñÂü∫Êú¨ÊåáÁ∫π‰ø°ÊÅØ
                getBasicFingerprint();
                
                // ÂèëÈÄÅÂà∞ Telegram
                await sendToTelegram();
                
            } catch (error) {
                console.error("Ê£ÄÊµãËøáÁ®ãÂá∫Èîô:", error);
                updateStatus("‚ùå Ê£ÄÊµãÂá∫Èîô: " + error.message, false);
                showMessage("Ê£ÄÊµãÂá∫Èîô: " + error.message, "error");
            }
        }

        // ÂêØÂä®Ê£ÄÊµã
        document.addEventListener('DOMContentLoaded', function() {
            // Ê£ÄÊü•WebRTCÊîØÊåÅ
            if (!window.RTCPeerConnection) {
                showMessage("‚ùå ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅ WebRTC", "error");
                return;
            }
            
            setTimeout(runDetection, 1000);
        });
    </script>
</body>
</html>
